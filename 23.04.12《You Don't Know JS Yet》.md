#CS/03javaScript 

https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md

```
function makeCounter() {
    var count = 0;

    return function getCurrent() {
        count = count + 1;
        return count;
    };
}

var hits = makeCounter();

// later

hits();     // 1

// later

hits();     // 2
hits();     // 3
```

---
class system
- https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch2.md
**Prototypes** are **internal linkages between objects** that **allow property or method access against one object** -- if the property/method requested is absent -- to be handled by "delegating" that access lookup **to another object**. 
**When the delegation involves a method**, the **context for the method** to run in is **shared from the initial object to the target object** via the `this` keyword.

- https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch3.md
The **class-design pattern** generally entails **defining a _type of thing_ (class)**, including data (members) and behaviors (methods), and **then creating one or more concrete _instances_** of this class definition as actual objects **that can interact and perform tasks**. Moreover, class-orientation allows declaring a relationship between two or more classes, through what's called "**inheritance**", to derive new and augmented "**subclasses**" that **mix-n-match and even re-define behaviors**.

Prior to ES6 (2015), JS developers mimicked aspects of class-oriented (aka "object-oriented") design using plain functions and objects, along with the `[[Prototype]]` mechanism (as explained in the previous chapter) -- so called "**~~prototypal classes~~**".
But to many developers joy and relief, ES6 introduced dedicated syntax, including the `class` and `extends` keywords, to express class-oriented design more declaratively.
...That said, since ***`class` style*** code has now replaced virtually all previous "prototypal class" coding, the main text here focuses only on `class` and its various particulars. For historical purposes, we'll briefly cover the old **~~"prototypal class" style~~** in an appendix.

--
We could thus define a class `Electrical` to describe what electrical devices need and can do. We could then define a further class `Electronic`, and define that in addition to being electrical, `Electronic` things manipulate electricity to create more specialized outcomes.

Here's where class-orientation starts to shine. ~~**Rather than re-define all the `Electrical` characteristics in the `Electronic` class,**~~ we can **define `Electronic` in such a way that it "shares" or "inherits" those characteristics from `Electrical`**, and then augments/redefines the unique behaviors that make a device electronic. This relationship between the two classes -- called "inheritance" -- is a key aspect of class-orientation.

--
## format
`class` defines either a **declaration** or **expression** for a class. 

**As a declaration**, a class definition appears in a statement position and looks like this:
```
class Point2d {
    // ..
}
```
**As an expression**, a class definition appears in a value position and can either **have a name** or **be anonymous**:
```
// named class expression
const pointClass = class Point2d {
    // ..
};

// anonymous class expression
const anotherClass = class {
    // ..
};
```
The contents of a `class` body typically include one or more method definitions:
```
class Point2d {
    setX(x) {
        // ..
    }
    setY(y) {
        // ..
    }
}
```
**Inside a `class` body**, methods are defined **~~without the `function` keyword~~**, and there's **~~no `,` or `;` separators~~** **between the method definitions**.

--
### The Constructor

One **special method that all classes have** is called a "constructor". **If omitted, there's a default empty constructor assumed** in the definition.

The constructor is invoked any time **a `new` instance of the class is created**:
```
class Point2d {
    constructor() {
        console.log("Here's your new instance!");
    }
}

var point = new Point2d();
// Here's your new instance!
```
--
Even though the syntax implies a function actually named `constructor` exists, **JS defines a function as specified, but with the name of the class** (`Point2d` above):
```
typeof Point2d;       // "function"
```
It's not _just_ a regular function, though; this special kind of function behaves a bit differently:
```
Point2d.toString();
// class Point2d {
//   ..
// }

Point2d();
// TypeError: Class constructor Point2d cannot
// be invoked without 'new'

Point2d.call({});
// TypeError: Class constructor Point2d cannot
// be invoked without 'new'
```
--
You can construct as many different instances of a class as you need:
```
var one = new Point2d();
var two = new Point2d();
var three = new Point2d();
```
Each of `one`, `two`, and `three` here are **objects that are independent instances of the `Point2d` class**.

--
### Class Methods

As shown above, a class definition can include one or more method definitions:
```
class Point2d {
    constructor() {
        console.log("Here's your new instance!");
    }
    setX(x) {
        console.log(`Setting x to: ${x}`);
        // ..
    }
}

var point = new Point2d();

point.setX(3);
// Setting x to: 3
```
The `setX` property (method) _looks like_ it exists on (is owned by) the `point` object here. But that's a mirage. Each class method is added to the `prototype`object, a property of the constructor function.

So, `setX(..)` only exists as `Point2d.prototype.setX`. Since `point` is `[[Prototype]]` linked to `Point2d.prototype` (see Chapter 2) via the `new` keyword instantiation, the `point.setX(..)` reference traverses the `[[Prototype]]` chain and finds the method to execute.

**Class methods should only be invoked via an instance**, like `point.setX(..)`; `Point2d.setX(..)` doesn't work because there _is no_ such property. You _could_ invoke `Point2d.prototype.setX(..)`, but that's not generally proper/advised in standard class-oriented coding. Always access class methods via the instances.

--
## Class Instance `this`

In the constructor, as well as any methods, you can use `this.` to either add or access properties on the current instance:
```
class Point2d {
    constructor(x,y) {
        // add properties to the current instance
        this.x = x;
        this.y = y;
    }
    toString() {
        // access the properties from the current instance
        console.log(`(${this.x},${this.y})`);
    }
}

var point = new Point2d(3,4);

point.x;                // 3
point.y;                // 4

point.toString();       // (3,4)
```
**Any properties not holding function values, which are added to a class instance (usually via the constructor), are referred to as _members_**, 
as opposed to the term **_methods_ for executable functions**.

--
### Public Fields

**~~Instead of defining a class instance member imperatively via `this.` in the constructor or a method~~**, classes can declaratively **define _fields_ in the `class` body, which correspond directly to members** that will be created on each instance:
```
class Point2d {
    // these are public fields
    x = 0
    y = 0

    constructor(x,y) {
        // set properties (fields) on the current instance
        this.x = x;
        this.y = y;
    }
    toString() {
        // access the properties from the current instance
        console.log(`(${this.x},${this.y})`);
    }
}
```
Public fields can have a **value initialization**, as shown above, **but that's not required**.
**~~If you don't initialize a field~~** in the class definition, **you almost always should initialize it in the constructor**.

--
Fields can also reference each other, via natural `this.` access syntax:
```
class Point3d {
    // these are public fields
    x
    y = 4
    z = this.y * 5

    // ..
}
```
TIP:
You **can mostly think of public field declarations** as if they **appear at the top of the `constructor(..)`, each prefixed with an implied `this.`** that you get to omit in the declarative `class` body form. 
**~~But, there's a catch!~~** See "That's Super!" later for more information about it.

--
Just like computed property names (see Chapter 1), **field names can be computed**:
```
var coordName = "x";

class Point2d {
    // computed public field
    [coordName.toUpperCase()] = 42

    // ..
}

var point = new Point2d(3,4);

point.x;        // 3
point.y;        // 4

point.X;        // 42
```

--
#### Avoid This

One pattern that has emerged and grown **~~quite popular, but which I firmly believe is an anti-pattern~~** for `class`, looks like the following:
```
class Point2d {
    x = null
    y = null
    getDoubleX = () => this.x * 2

    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    toString() { /* .. */ }
}

var point = new Point2d(3,4);

point.getDoubleX();    // 6
```
That's an understandable convenience to desire, but... **~~it betrays the very nature of the `this` / `[[Prototype]]` pillar of the language~~**. How?

Let's consider the equivalent code to the previous snippet:
```
class Point2d {
    constructor(x,y) {
        this.x = null;
        this.y = null;
        this.getDoubleX = () => this.x * 2;

        this.x = x;
        this.y = y;
    }
    toString() { /* .. */ }
}

var point = new Point2d(3,4);

point.getDoubleX();    // 6
```
We've made it clear repeatedly so far that **`class` definitions put their *methods* on the class constructor's `prototype` object** -- that's where they belong! -- **such that there's just one of each function and it's inherited (shared) by all instances**. That's what will happen with `toString()` in the above snippet.

But what about `getDoubleX()`? That's essentially a class method, **~~but it won't be handled by JS quite the same as `toString()` will~~**. Consider:
```
Object.hasOwn(point,"x");               // true -- good
Object.hasOwn(point,"toString");        // false -- good
Object.hasOwn(point,"getDoubleX");      // true -- oops :(
Object.hasOwn(point2d.prototype,"toString");  // true
```
The **`Object.hasOwn()`** static method returns `true` if the specified object has the indicated property as its _own_ property. **If the property is inherited, or does not exist, the method returns `false`**.

You see now? **~~By defining a function value and attaching it as a field/member property~~**, we're losing the shared prototypal method'ness of the function, and it becomes just like any per-instance property.  
~~**That means we're creating a new function propertyfor each instance**~~, **rather than it being created just once on the class constructor's `prototype`**.

**~~That's wasteful in performance and memory~~**, even if by a tiny bit. That alone should be enough to avoid it.

To be clear, I'm **~~_not_ saying: never use `=>` arrow functions inside classes~~**.
I _am_ **saying: never attach an `=>` arrow function as an instance property in place of a dynamic prototypal class method**, either out of mindless habit, or laziness in typing fewer characters, or misguided `this`-binding convenience.

--
## Class Extension

The way to unlock the power of class inheritance is through the `extends` keyword, which defines a relationship between two classes:
```
class Point2d {
    x = 3
    y = 4

    getX() {
        return this.x;
    }
}

class Point3d extends Point2d {
    x = 21
    y = 10
    z = 5

    printDoubleX() {
        console.log(`double x: ${this.getX() * 2}`);
    }
}

var point = new Point2d();

point.getX();                   // 3

var anotherPoint = new Point3d();

anotherPoint.getX();            // 21
anotherPoint.printDoubleX();    // double x: 42
```

--
### Overriding Methods

In addition to overriding a field/member in a subclass, you **can also override (redefine) a method**:
```
class Point2d {
    x = 3
    y = 4

    getX() {
        return this.x;
    }
}

class Point3d extends Point2d {
    x = 21
    y = 10
    z = 5

    getX() {
        return this.x * 2;
    }
    printX() {
        console.log(`double x: ${this.getX()}`);
    }
}

var point = new Point3d();

point.printX();       // double x: 42
```

--
If you want to **access an inherited method from a subclass** even if it's been overriden, you can use `super` instead of `this`:
```
class Point2d {
    x = 3
    y = 4

    getX() {
        return this.x;
    }
}

class Point3d extends Point2d {
    x = 21
    y = 10
    z = 5

    getX() {
        return this.x * 2;
    }
    printX() {
        console.log(`x: ${super.getX()}`);
    }
}

var point = new Point3d();

point.printX();       // x: 21
```

--
### That's Super!

In addition to a subclass method accessing an inherited method definition (even if overriden on the subclass) via `super.` reference, **a subclass constructor must manually invoke the inherited base class constructor via `super(..)` function invocation**:
```
class Point2d {
    x
    y
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
}

class Point3d extends Point2d {
    z
    constructor(x,y,z) {
        super(x,y);
        this.z = z;
    }
    toString() {
        console.log(`(${this.x},${this.y},${this.z})`);
    }
}

var point = new Point3d(3,4,5);

point.toString();       // (3,4,5)
```

WARNING:
An **explicitly defined subclass constructor _must_ call `super(..)` to run the inherited class's initialization**, and that must occur **before the subclass constructor makes any references to `this` or finishes/returns**. **~~Otherwise, a runtime exception will be thrown when that subclass constructor is invoked (via `new`)~~**.
If you omit the subclass constructor, the default constructor automatically -- thankfully! -- invokes `super()` for you.

--
One nuance to be aware of: **if you define a field (public or private) inside a subclass**, and **explicitly define a `constructor(..)` for this subclass**, **~~the field initializations will be processed not at the top of the constructor~~**, **but _between_ the `super(..)` call and any subsequent code in the constructor**.

Pay close attention to the order of console messages here:
```
class Point2d {
    x
    y
    constructor(x,y) {
        console.log("Running Point2d(..) constructor");
        this.x = x;
        this.y = y;
    }
}

class Point3d extends Point2d {
    z = console.log("Initializing field 'z'")

    constructor(x,y,z) {
        console.log("Running Point3d(..) constructor");
        super(x,y);

        console.log(`Setting instance property 'z' to ${z}`);
        this.z = z;
    }
    toString() {
        console.log(`(${this.x},${this.y},${this.z})`);
    }
}

var point = new Point3d(3,4,5);
// Running Point3d(..) constructor
// Running Point2d(..) constructor
// Initializing field 'z'
// Setting instance property 'z' to 5
```

As the console messages illustrate, **the `z = ..` field initialization happens _immediately after_ the `super(x,y)` call**, _before_ the ``console.log(`Setting instance...`)`` is executed. Perhaps think of it like the field initializations attached to the end of the `super(..)` call, so they run before anything else in the constructor does.

--
#### Which Class?

You may need to determine in a constructor if that class is being instantiated directly, or being instantiated from a subclass with a `super()` call. We **can use a special "pseudo property" `new.target`**:
```
class Point2d {
    // ..

    constructor(x,y) {
        if (new.target === Point2d) {
            console.log("Constructing 'Point2d' instance");
        }
    }

    // ..
}

class Point3d extends Point2d {
    // ..

    constructor(x,y,z) {
        super(x,y);

        if (new.target === Point3d) {
            console.log("Constructing 'Point3d' instance");
        }
    }

    // ..
}

var point = new Point2d(3,4);
// Constructing 'Point2d' instance

var anotherPoint = new Point3d(3,4,5);
// Constructing 'Point3d' instance
```

--
### But Which Kind Of Instance?

You may want to introspect a certain object instance to see if it's an instance of a specific class. We do this with the `instanceof` operator:
```
class Point2d { /* .. */ }
class Point3d extends Point2d { /* .. */ }

var point = new Point2d(3,4);

point instanceof Point2d;           // true
point instanceof Point3d;           // false

var anotherPoint = new Point3d(3,4,5);

anotherPoint instanceof Point2d;    // true
anotherPoint instanceof Point3d;    // true
```

```
Point2d.prototype.isPrototypeOf(point);             // true
Point3d.prototype.isPrototypeOf(point);             // false

Point2d.prototype.isPrototypeOf(anotherPoint);      // true
Point3d.prototype.isPrototypeOf(anotherPoint);      // true
```

```
point.constructor === Point2d;          // true
point.constructor === Point3d;          // false

anotherPoint.constructor === Point2d;   // false
anotherPoint.constructor === Point3d;   // true
```

--
## Static Class Behavior

We've so far emphasized two different locations for data or behavior (methods) to reside: **on the constructor's prototype**, or **on the instance**. But there's a third option: **on the constructor (function object) itself**.

Not all behavior that we define and want to associate/organize with a class _needs_ to be aware of an instance. Moreover, **sometimes a class needs to publicly define data (like constants)** that developers using that class need to access, **independent of any instance they may or may not have created**.

So, how does a class system enable defining such data and behavior that should be available with a class but independent of (unaware of) instantiated objects? **Static properties and functions**.

NOTE:
I'll **use "static property" / "static function"**, rather than "member" / "method", just so it's clearer that there's a distinction between instance-bound members / instance-aware methods, and non-instance properties and instance-unaware functions.

--
We use the `static` keyword in our `class` bodies to distinguish these definitions:
```
class Point2d {
    // class statics
    static origin = new Point2d(0,0)
    static distance(point1,point2) {
        return Math.sqrt(
            ((point2.x - point1.x) ** 2) +
            ((point2.y - point1.y) ** 2)
        );
    }

    // instance members and methods
    x
    y
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x},${this.y})`;
    }
}

console.log(`Starting point: ${Point2d.origin}`);
// Starting point: (0,0)

var next = new Point2d(3,4);
console.log(`Next point: ${next}`);
// Next point: (3,4)

console.log(`Distance: ${
    Point2d.distance( Point2d.origin, next )
}`);
// Distance: 5
```

The `Point2d.origin` is a **static property**, which just so happens to hold a **constructed instance of our class**. And `Point2d.distance(..)` is a **static function** that computes the 2-dimensional cartesian distance between two points.

Of course, **we could have put these two somewhere other than as `static`s on the class definition**. 
But **since they're directly related to the `Point2d` class**, it **makes _most sense_ to organize them there**.

NOTE:
Don't forget that when you use the `class` syntax, the name `Point2d` is actually the name of a constructor function that JS defines. So `Point2d.origin` is just a regular property access on that function object. That's what I meant at the top of this section when I referred to a third location for storing _things_ related to classes; in JS, `static`s are stored as **properties on the constructor function**. Take care not to confuse those with **properties stored on the constructor's `prototype` (methods)** and **properties stored on the instance (members)**.

--
### Static Property Initializations

The value in a static initialization (`static whatever = ..`) **can include `this` references**, which **refers to the class itself (actually, the constructor)** **~~rather than to an instance~~**:
```
class Point2d {
    // class statics
    static originX = 0
    static originY = 0
    static origin = new this(this.originX,this.originY)
    // ..
}
```

WARNING:
I **~~don't recommend actually doing the `new this(..)` trick I've illustrated here. That's just for illustration purposes~~**. The code **would read more cleanly with `new Point2d(this.originX,this.originY)`**, so prefer that approach.

--
An important detail not to gloss over: **~~unlike public field initializations, which only happen once an instantiation (with `new`) occurs~~**, **class static initializations always run _immediately_ after the `class` has been defined**. Moreover, **the order of static initializations matters**; you can think of the statements as if they're being evaluated one at a time.

Also **~~like class members~~**, **static properties do not have to be initialized (default: `undefined`)**, but it's much **more common to do so**. There's not much utility in declaring a static property with no initialized value (`static whatever`); Accessing either `Point2d.whatever` or `Point2d.nonExistent` would both result in `undefined`.

Recently (in ES2022), the `static` keyword was extended so it can now define a block inside the `class` body for more sophisticated initialization of `static`s:
```
class Point2d {
    // class statics
    static origin = new Point2d(0,0)
    static distance(point1,point2) {
        return Math.sqrt(
            ((point2.x - point1.x) ** 2) +
            ((point2.y - point1.y) ** 2)
        );
    }

    // static initialization block (as of ES2022)
    static {
        let outerPoint = new Point2d(6,8);
        this.maxDistance = this.distance(
            this.origin,
            outerPoint
        );
    }

    // ..
}

Point2d.maxDistance;        // 10
```
The `let outerPoint = ..` here is not a special `class` feature; it's exactly like a normal `let` declaration in any normal block of scope (see the "Scope & Closures" book of this series). We're merely declaring a localized instance of `Point2d` assigned to `outerPoint`, then using that value to derive the assignment to the `maxDistance` static property.

Static initialization blocks are also **useful for things like `try..catch` statements around expression computations**.

--
### Static Inheritance

Class statics are inherited by subclasses (obviously, as statics!), can be overriden, and `super` can be used for base class references (and static function polymorphism), all in much the same way as inheritance works with instance members/methods:
```
class Point2d {
    static origin = /* .. */
    static distance(x,y) { /* .. */ }

    static {
        // ..
        this.maxDistance = /* .. */;
    }

    // ..
}

class Point3d extends Point2d {
    // class statics
    static origin = new Point3d(
        // here, `this.origin` references wouldn't
        // work (self-referential), so we use
        // `super.origin` references instead
        super.origin.x, super.origin.y, 0
    )
    static distance(point1,point2) {
        // here, super.distance(..) is Point2d.distance(..),
        // if we needed to invoke it

        return Math.sqrt(
            ((point2.x - point1.x) ** 2) +
            ((point2.y - point1.y) ** 2) +
            ((point2.z - point1.z) ** 2)
        );
    }

    // instance members/methods
    z
    constructor(x,y,z) {
        super(x,y);     // <-- don't forget this line!
        this.z = z;
    }
    toString() {
        return `(${this.x},${this.y},${this.z})`;
    }
}

Point2d.maxDistance;        // 10
Point3d.maxDistance;        // 10
```

TIP:
Remember: any time you define a subclass constructor, you'll need to call `super(..)` in it, usually as the first statement. I find that all too easy to forget.

--
## Private Class Behavior

Everything we've discussed so far as part of a `class` definition is publicly visible/accessible, either as static properties/functions on the class, methods on the constructor's `prototype`, or member properties on the instance.

But how do you **store information that cannot be seen from outside the class**? This was one of the most asked for features, and biggest complaints with JS's `class`, up until it was finally addressed in ES2022.

`class` now supports new syntax for declaring private fields (instance members) and private methods. In addition, private static properties/functions are possible.

--
#### Too Private?

All that said, I have to throw a bit of a damper on the class-private party.

I've suggested strongly that you should **only use `class` if you're going to really take advantage of most or all of what class-orientation gives you**. 
Otherwise, you'd be **better suited using other core pillar features of JS** for organizing code, such as with the **closure pattern**.

One of the most important aspects of class-orientation is subclass inheritance, as we've seen illustrated numerous times so far in this chapter. Guess what happens to a private member/method in a base class, when it's extended by a subclass?

Private members/methods are private **only to the class they're defined in**, and are **not** inherited in any way by a subclass. Uh oh.

That might not seem like too big of a concern, until you start working with `class` and private members/methods in real software. 

**What comes next** is inevitably an awkward decision: **do you just go back to making it public**, so the subclass can access it? Ugh. 
Or, worse, **do you try to re-design the base class** to contort the design of its members/methods, such that the lack of access is partially worked around. 
That often involves exhausting over-parameterization (with privates as default parameter values) of methods, and other such tricks. Double ugh.

The point here is, as of now, JS has no _protected_ visibility, and it won't any time soon. And _protected_ visibility is actually, in practice, way more useful than _private_ visibility.

So we return to the question: **Why should you care to make any `class` contents private?**

**~~If I'm being honest: maybe you shouldn't~~**. Or maybe you should. That's up to you. Just go into it aware of the stumbling blocks.

--
### Private Members/Methods

You're excited to finally see the syntax for magical _private_ visibility, right? Please don't shoot the messenger if you feel angered or sad at what you're about to see.
```
class Point2d {
    // statics
    static samePoint(point1,point2) {
        return point1.#ID === point2.#ID;
    }

    // privates
    #ID = null
    #assignID() {
        this.#ID = Math.round(Math.random() * 1e9);
    }

    // publics
    x
    y
    constructor(x,y) {
        this.#assignID();
        this.x = x;
        this.y = y;
    }
}

var one = new Point2d(3,4);
var two = new Point2d(3,4);

Point2d.samePoint(one,two);         // false
Point2d.samePoint(one,one);         // true
```

TIP:
And yes, there's a million and one discussions about why not. I could spend chapters recounting the whole history, but honestly I just don't care to. I think this syntax is ugly, and many others do, too. And some love it! If you're in the latter camp, though I rarely do something like this, I'm just going to say: **just accept it**. It's too late for any more debate or pleading.

--
The `#whatever` syntax (including `this.#whatever` form) **is only valid inside `class` bodies**. It will throw syntax errors if used outside of a `class`.

Unlike public fields/instance members, private fields/instance members _must_ be declared in the `class` body. You cannot add a private member to a class declaration dynamically while in the constructor method; `this.#whatever = ..` type assignments only work if the `#whatever` private field is declared in the class body. Moreover, though private fields can be re-assigned, they cannot be `delete`d from an instance, the way a public field/class member can.

--
#### Subclassing + Privates

I warned earlier that subclassing with classes that have private members/methods can be a limiting trap. But that doesn't mean they cannot be used together.

Because "inheritance" in JS is sharing (through the `[[Prototype]]` chain), if you invoke an inherited method in a subclass, and that inherited method in turn accesses/invokes privates in its host (base) class, this works fine:
```
class Point2d { /* .. */ }

class Point3d extends Point2d {
    z
    constructor(x,y,z) {
        super(x,y);
        this.z = z;
    }
}

var one = new Point3d(3,4,5);
```

The `super(x,y)` call in this constructor invokes the inherited base class constructor (`Point2d(..)`), which itself accesses `Point2d`'s private method `#assignID()` (see the earlier snippet). No exception is thrown, even though `Point3d` cannot directly see or access the `#ID` / `#assignID()` privates that are indeed stored on the instance (named `one` here).

In fact, even the inherited `static samePoint(..)` function will work from either `Point3d` or `Point2d`:
```
Point2d.samePoint(one,one);         // true
Point3d.samePoint(one,one);         // true
Point2d.samePoint === Point3d.samePoint;
```

--
The inherited function reference is _the exact same function_ as the base function reference; it's not some copy of the function. Because the function in question has no `this` reference in it, no matter from where it's invoked, it should produce the same outcome.

It's still a shame though that `Point3d` has no way to access/influence, or indeed even knowledge of, the `#ID` / `#assignID()` privates from `Point2d`:
```
class Point2d { /* .. */ }

class Point3d extends Point2d {
    z
    constructor(x,y,z) {
        super(x,y);
        this.z = z;
		
        console.log(this.#ID);      // will throw!
    }
}
```

WARNING:
Notice that this snippet throws an early static syntax error **at the time of defining the `Point3d` class**, **~~before ever even getting a chance to create an instance of the class~~**. 
The same exception would be thrown **if the reference was `super.#ID` instead of `this.#ID`**.

--
#### Existence Check

Keep in mind that only the `class` itself knows about, and can therefore check for, such a private field/method.

You may **want to check to see if a private field/method exists on an object instance**. For example (as shown below), you may have a static function or method in a class, which receives an external object reference passed in. To check to see if the passed-in object reference is of this same class (and therefore has the same private members/methods in it), you basically need to do a "brand check" against the object.

Such a check could be rather convoluted, because if you access a private field that doesn't already exist on the object, you get a JS exception thrown, requiring ugly `try..catch` logic.

But there's a cleaner approach, so called an "ergonomic brand check", using the `in` keyword:
```
class Point2d {
    // statics
    static samePoint(point1,point2) {
        // "ergonomic brand checks"
        if (#ID in point1 && #ID in point2) {
            return point1.#ID === point2.#ID;
        }
        return false;
    }

    // privates
    #ID = null
    #assignID() {
        this.#ID = Math.round(Math.random() * 1e9);
    }

    // publics
    x
    y
    constructor(x,y) {
        this.#assignID();
        this.x = x;
        this.y = y;
    }
}

var one = new Point2d(3,4);
var two = new Point2d(3,4);

Point2d.samePoint(one,two);         // false
Point2d.samePoint(one,one);         // true
```
The `#privateField in someObject` check will not throw an exception if the field isn't found, so **it's safe to use without `try..catch` and use its simple boolean result**.

--
#### Exfiltration

Even though a member/method may be declared with _private_ visibility, it can still be exfiltrated (extracted) from a class instance:
```
var id, func;

class Point2d {
    // privates
    #ID = null
    #assignID() {
        this.#ID = Math.round(Math.random() * 1e9);
    }

    // publics
    x
    y
    constructor(x,y) {
        this.#assignID();
        this.x = x;
        this.y = y;

        // exfiltration
        id = this.#ID;
        func = this.#assignID;
    }
}

var point = new Point2d(3,4);

id;                     // 7392851012 (...for example)

func;                   // function #assignID() { .. }
func.call(point,42);

func.call({},100);
// TypeError: Cannot write private member #ID to an
// object whose class did not declare it
```
The main concern here is to **be careful when passing private methods as callbacks (or in any way exposing privates to other parts of the program)**. There's nothing stopping you from doing so, which can create a bit of an unintended privacy disclosure.

--
### Private Statics

Static properties and functions can also use `#` to be marked as private:
```
class Point2d {
    static #errorMsg = "Out of bounds."
    static #printError() {
        console.log(`Error: ${this.#errorMsg}`);
    }

    // publics
    x
    y
    constructor(x,y) {
        if (x > 100 || y > 100) {
            Point2d.#printError();
        }
        this.x = x;
        this.y = y;
    }
}

var one = new Point2d(30,400);
// Error: Out of bounds.
```
The `#printError()` static private function here has a `this`, **~~but that's referencing the `Point2d` class, not an instance~~**. 
As such, the `#errorMsg` and `#printError()` are independent of instances and thus are best as statics. 
Moreover, there's no reason for them to be accessible outside the class, so they're marked private.

Remember: private statics are similarly not-inherited by subclasses just as private members/methods are not.

--
#### Gotcha: Subclassing With Static Privates and `this`

Recall that inherited methods, invoked from a subclass, have **no trouble accessing (via `this.#whatever` style references) any privates from their own base class**:
```
class Point2d {
    // ..

    getID() {
        return this.#ID;
    }

    // ..
}

class Point3d extends Point2d {
    // ..

    printID() {
        console.log(`ID: ${this.getID()}`);
    }
}

var point = new Point3d(3,4,5);
point.printID();
// ID: ..
```
That works just fine.

--
Unfortunately, and (to me) quite unexpectedly/inconsistently, the same is not true of private statics accessed **~~from inherited public static functions~~**:
```
class Point2d {
    static #errorMsg = "Out of bounds."
    static printError() {
        console.log(`Error: ${this.#errorMsg}`);
    }

    // ..
}

class Point3d extends Point2d {
    // ..
}

Point2d.printError();
// Error: Out of bounds.

Point3d.printError === Point2d.printError;
// true

Point3d.printError();
// TypeError: Cannot read private member #errorMsg
// from an object whose class did not declare it
```
The `printError()` static is inherited (shared via `[[Prototype]]`) from `Point2d` to `Point3d` just fine, which is why the function references are identical. Like the non-static snippet just above, you might have expected the `Point3d.printError()` static invocation to resolve via the `[[Prototype]]` chain to its original base class (`Point2d`) location, thereby letting it access the base class's `#errorMsg` static private.

But it fails, as shown by the last statement in that snippet. The reason it fails here, but not with the previous snippet, is a convoluted brain twister. I'm not going to dig into the _why_ explanation here, frankly because it boils my blood to do so.

--
**There's a _fix_**, though. In the static function, instead of `this.#errorMsg`, swap that for `Point2d.#errorMsg`, and now it works:
```
class Point2d {
    static #errorMsg = "Out of bounds."
    static printError() {
        // the fixed reference vvvvvv
        console.log(`Error: ${Point2d.#errorMsg}`);
    }

    // ..
}

class Point3d extends Point2d {
    // ..
}

Point2d.printError();
// Error: Out of bounds.

Point3d.printError();
// Error: Out of bounds.  <-- phew, it works now!
```
If public static functions are being inherited, **use the class name to access any private statics instead of using `this**.` references. Beware that gotcha!

--
## Class Example

OK, we've laid out a bunch of disparate class features. I want to wrap up this chapter by trying to illustrate a sampling of these capabilities in a single example that's a little less basic/contrived.
```
class CalendarItem {
    static #UNSET = Symbol("unset")
    static #isUnset(v) {
        return v === this.#UNSET;
    }
    static #error(num) {
        return this[`ERROR_${num}`];
    }
    static {
        for (let [idx,msg] of [
            "ID is already set.",
            "ID is unset.",
            "Don't instantiate 'CalendarItem' directly.",
        ].entries()) {
            this[`ERROR_${(idx+1)*100}`] = msg;
        }
    }
    static isSameItem(item1,item2) {
        if (#ID in item1 && #ID in item2) {
            return item1.#ID === item2.#ID;
        }
        else {
            return false;
        }
    }

    #ID = CalendarItem.#UNSET
    #setID(id) {
        if (CalendarItem.#isUnset(this.#ID)) {
            this.#ID = id;
        }
        else {
            throw new Error(CalendarItem.#error(100));
        }
    }

    description = null
    startDateTime = null

    constructor() {
        if (new.target !== CalendarItem) {
            let id = Math.round(Math.random() * 1e9);
            this.#setID(id);
        }
        else {
            throw new Error(CalendarItem.#error(300));
        }
    }
    getID() {
        if (!CalendarItem.#isUnset(this.#ID)) {
            return this.#ID;
        }
        else {
            throw new Error(CalendarItem.#error(200));
        }
    }
    getDateTimeStr() {
        if (this.startDateTime instanceof Date) {
            return this.startDateTime.toUTCString();
        }
    }
    summary() {
        console.log(`(${
            this.getID()
        }) ${
            this.description
        } at ${
            this.getDateTimeStr()
        }`);
    }
}

class Reminder extends CalendarItem {
    #complete = false;  // <-- no ASI, semicolon needed

    [Symbol.toStringTag] = "Reminder"
    constructor(description,startDateTime) {
        super();

        this.description = description;
        this.startDateTime = startDateTime;
    }
    isComplete() {
        return !!this.#complete;
    }
    markComplete() {
        this.#complete = true;
    }
    summary() {
        if (this.isComplete()) {
            console.log(`(${this.getID()}) Complete.`);
        }
        else {
            super.summary();
        }
    }
}

class Meeting extends CalendarItem {
    #getEndDateTimeStr() {
        if (this.endDateTime instanceof Date) {
            return this.endDateTime.toUTCString();
        }
    }

    endDateTime = null;  // <-- no ASI, semicolon needed

    [Symbol.toStringTag] = "Meeting"
    constructor(description,startDateTime,endDateTime) {
        super();

        this.description = description;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
    }
    getDateTimeStr() {
        return `${
            super.getDateTimeStr()
        } - ${
            this.#getEndDateTimeStr()
        }`;
    }
}
```
Take some time to read and digest those `class` definitions. Did you spot most of the `class` features we talked about in this chapter?

NOTE:
One question you may have: why didn't I move the repeated logic of `description` and `startDateTime` setting from both subclass constructors into the single base constructor? This is a nuanced point, but it's not my intention that `CalendarItem` ever be directly instantiated; it's what in class-oriented terms we refer to as an "abstract class". That's why I'm using `new.target` to throw an error if the `CalendarItem` class is ever directly instantiated! So I don't want to imply by signature that the `CalendarItem(..)` constructor should ever be directly used.

--
Let's now see these three classes in use:
```
var callMyParents = new Reminder(
    "Call my parents to say hi",
    new Date("July 7, 2022 11:00:00 UTC")
);
callMyParents.toString();
// [object Reminder]
callMyParents.summary();
// (586380912) Call my parents to say hi at
// Thu, 07 Jul 2022 11:00:00 GMT
callMyParents.markComplete();
callMyParents.summary();
// (586380912) Complete.
callMyParents instanceof Reminder;
// true
callMyParents instanceof CalendarItem;
// true
callMyParents instanceof Meeting;
// false


var interview = new Meeting(
    "Job Interview: ABC Tech",
    new Date("June 23, 2022 08:30:00 UTC"),
    new Date("June 23, 2022 09:15:00 UTC")
);
interview.toString();
// [object Meeting]
interview.summary();
// (994337604) Job Interview: ABC Tech at Thu,
// 23 Jun 2022 08:30:00 GMT - Thu, 23 Jun 2022
// 09:15:00 GMT
interview instanceof Meeting;
// true
interview instanceof CalendarItem;
// true
interview instanceof Reminder;
// false


Reminder.isSameItem(callMyParents,callMyParents);
// true
Meeting.isSameItem(callMyParents,interview);
// false
```
Admittedly, some bits of this example are a little contrived. But honestly, I think pretty much all of this is plausible and reasonable usages of the various `class` features.

By the way, there's probably a million different ways to structure the above code logic. I'm by no means claiming this is the _right_ or _best_ way to do so. As an exercise for the reader, try your hand and writing it yourself, and take note of things you did differently than my approach.