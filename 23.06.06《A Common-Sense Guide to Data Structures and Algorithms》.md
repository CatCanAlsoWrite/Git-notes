#read/《A_Common-Sense_Guide_to_Data_Structures_and_Algorithms》 #CS/07dataStructure 

- [book](https://usermanual.wiki/Document/A20Common20Sense20Guide20To20Data20Structures20And20Algorithms2020Jay20Wengrow.1281995573.pdf)
- [exercise](https://commonsensecomputerscience.com/old-site/index.html)

- Content-p6
- concepts
	- when we measure **how “fast” an operation takes**, we do not refer to ~~how fast the operation takes in terms of pure time~~, but instead in **how many steps it takes**.
- Chapter 1-p21 Why Data Structures Matter 
	- p23 The **Array**: The Foundational Data Structure
		- **operations**
			- **Read**: Reading refers to looking something up from a particular spot within the data structure. **One step**.
				- eg: `array[0]`, which grocery item is located at index 2 would be reading from the array.
			- **Search**: Searching refers to looking for a particular value within a data structure. 
				- **linear search algorithm**: for N cells in an array, linear search will take a **maximum of N steps**. 
					- eg: `array.include("value")`, if "dates" is in our grocery list, and which index it’s located at would be searching the array.
				- **binary search algorithm** (in chapter 2, can only be used in ordered arrays)
			- **Insert**: Insertion refers to adding another value to our data structure. 
				- **at the end** of an array: **one step**. eg: `array.push("value")`, add "value" to our shopping list.
				- **at the beginning or the middle** of an array: for N cells in an array, insert will take a **maximum of N+1 steps**.  
			- **Delete**: Deletion refers to removing a value from our data structure. eg: `???`, removed "bananas" from our grocery list
				- **at the end** of an array: **one step**. 
				- **at the beginning or the middle** of an array: for N cells in an array, delete will take a **maximum of N steps**.  
	- p38 **Sets**: How a Single Rule Can Affect Efficiency
		- array-based set.
			- **Insert** (where arrays and sets diverge): **search (if duplicate) + insertion**
				- **at the end** of an array: for N cells in an array, insert will take a **maximum of N+ 1 steps**. 
				- **at the beginning or the middle** of an array: for N cells in an array, insert will take a **maximum of 2 N+1 steps**. 
	- ==Q: avoid sets just because insertion is slower for sets than regular arrays? ==
		- A: Absolutely not. 
			- **Sets** are important ***when you need to ensure that there is no duplicate data***. 
			- But ***when you don’t have such a need***, an **array may be preferable**, since **insertions for arrays are more efficient** than insertions for sets.
- Chapter 2-p43 Why Algorithms Matter 
	- **algorithm**: a particular **process for solving a problem**. When applied to computing, an algorithm refers to a **process for going about a particular operation**.
		- eg: the process for preparing a bowl of cereal can be called an algorithm. The cerealpreparation algorithm follows these four steps (for me, at least): 1. Grab a bowl. 2. Pour cereal in the bowl. 3. Pour milk in the bowl. 4. Dip a spoon in the bowl.
	- p45 **Ordered Arrays**: The major advantage of an ordered array over a standard array is that we **have the option of performing a binary search** rather than a linear search.
		- **Search**
			- **linear search algorithm**: (in chapter 1, for N cells in an array, linear search will take a **maximum of N steps**)				
			- **binary search algorithm**: Step1: We begin our search from the **central cell**. Step2: Among the cells **to the left of the central cell**, we inspect the **middlemost value**...repeat...StepN: We inspect the final remaining cell. (If it’s not there, that means that there is no "value" within this ordered array.)
				- The pattern that emerges is that for **every time we double the number of items in the ordered array**, the **number of steps needed for binary search increases by just one**.
		- Insert: **search (for the appropriate place) + insertion**
			- **at the beginning or the middle** of an array: for N cells in an array, Insert will take a **maximum of 2 N +1 steps**. 
		- **Delete**: **search (for the appropriate place) + delete**
			- **at the beginning or the middle** of an array: for N cells in an array, Insert will take a **maximum of 2 N +1 steps**.
	- ==Q: always use ordered arrays just because ordered arrays allow for binary search?==
		- A: No.
			- In situations ~~where you don’t anticipate searching the data much~~, **but only adding data**, **standard arrays may be a better choice** because their **insertion is faster**.
- Chapter 3-p59 Oh Yes! Big O Notation
	- ~~The more accurate way to quantify efficiency of linear search is to say that linear search takes N steps for N elements in the array. Of course, that’s a pretty wordy way of expressing this concept.~~ In order to help ease communication regarding time complexity, computer scientists have borrowed a concept from the world of mathematics: **Big O Notation**.
		- eg: the upper bound of the growth rate of a function, or that **if** a function g(x) **grows no faster than** a function f(x), then g is said to be a member of O(f).
	- Big O: describes the **number of steps that an algorithm takes**; or describes how many **steps an algorithm takes based on the number of data elements** that **the algorithm is acting upon**.
		- eg: array reading, or insertion and deletion of a value at the end of an array takes only one step, then count **"O(1)"** (pronounce “Oh of 1.”/“Big Oh of 1.”/“Order of 1.”), simply means that **the algorithm takes the same number of steps** no matter how much data there is.
		- eg: for N elements in the array, linear search can take up to a maximum of N steps, then use "**O(N)**" (pronounce “Oh of N.”)
	- Constant Time vs. Linear Time ![[Pasted image 20230607234104.png]]
		- **O(1)**, a **perfect horizontal line**, referred to as **constant time**. So, an **algorithm can be described as O(1) even if it takes more than one step**.![[Pasted image 20230607234719.png]] 
		- Q: how does the number of steps change as the data increases?
- Chapter 4-p76 Speeding Up Your Code with Big O
- Chapter 5-p96 Optimizing Code with and Without Big O